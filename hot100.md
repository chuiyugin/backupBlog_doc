---
title: 热题100学习笔记
tags:
  - 算法学习
categories:
  - 算法学习
date: 2025-9-7 15:00:00
excerpt: C++、编程语言、算法学习
---
# 热题100学习笔记
## 哈希
### 字母异位词分组
+ 字母异位词分组：[49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题目通过长度为 `26` 的 `string` 记录字母数量一样的字符串（由于 `unordered_map` 要求 `Key` 是可哈希的，因此 `Key` 不能够存 `vector` 类型），通过 `unordered_map` 来找到属于相同字母异位词的字符串，最后将其合并到数组中。

![字母异位词分组的存储结构](https://yugin-blog-1313489805.cos.ap-guangzhou.myqcloud.com/202509071517393.png)

+ 代码：

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> result;
        unordered_map<string, vector<string>> mp;
        for(int i=0; i<strs.size(); i++){
            string index(26, 0);
            for(int j=0; j<strs[i].size(); j++){
                index[strs[i][j] - 'a']++;
            }
            mp[index].push_back(strs[i]);
        }
        for(unordered_map<string, vector<string>>::iterator it = mp.begin(); it!=mp.end(); it++){
            result.push_back((*it).second);
        }
        return result;
    }
};
```

## 双指针
### 移动零
+ 移动零：[283.移动零](https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题目采用双指针的解法，首先定义 `left` 和 `right` 同时指向 `0` 位置，移动 `right` 指针，当 `right` 所指的元素不等于 `0` 时，交换 `left` 和 `right` 所指的元素，并且 `left` 右移一位。
	+ 需要注意的是不需要保证 `left` 初始指向的是 `0`，`left` 如果初始指向的是非 `0`，那么 `left` 和 `right` 就会指向同一个位置，同一个位置互换等于没有操作，之后 `left` 和 `right` 指针一起往右边移动一位。只有当 `left` 第一次值为 `0` 的时候，`right` 就会和 `left` 指针分离，直到找到一个非 `0` 的数然后跟 `left` 去进行交换。
+ 代码：

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0;
        for(int right = 0; right<nums.size(); right++){
            if(nums[right] != 0){
                swap(nums[left], nums[right]);
                left++;
            }
        }
    }
};
```

## 滑动窗口
### 无重复字符的最长子串
+ 无重复字符的最长子串：[3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：用两个指针 `left` 和 `right` 表示当前考察的窗口区间 `[left, right)`。`unordered_set<char>` 用来存储窗口内的字符，保证窗口内不出现重复。（滑动窗口+哈希集合）的问题。
	+ 当 `s[right]` 不在集合里时，说明窗口可以安全**扩张**，将 `s[right]` 插入集合，`right++` 向右移动，更新最大长度 `result = max(result, right - left)` 。
	+ 当 `s[right]` 已经在集合中时，说明出现重复字符，删除 `s[left]`， `left++` **收缩**窗口，直到窗口内没有重复字符。
+ 代码：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> se;
        int left = 0;
        int right = 0;
        int result = 0;
        while(right<s.size() && left<=right){
            if(se.find(s[right]) == se.end()){
                se.insert(s[right]);
                right++;
            }
            else{
                se.erase(s[left]);
                left++;
            }
            result = max(result, right-left);
        }
        return result;
    }
};
```

## 子串
### 和为 K 的子数组
+ 和为 K 的子数组：[560.和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题是典型的前缀和+哈希表解法，用来统计和为 `k` 的连续子数组个数。
	+ 在开始时放入 `mp[0] = 1`，表示「前缀和为 0 出现过 1 次」，这样可以处理从数组开头开始的子数组。
	+ 用一个哈希表 `mp` 存储某个前缀和出现的次数。在遍历过程中，此时前缀和为 `sum` 时，只要 `sum - k` 在哈希表中存在，说明之前有某个前缀和能让子数组和刚好为 `k`。于是把 `mp[sum - k]` 累加到答案 `ans` 中。
+ 代码：

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int sum = 0;
        int ans = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        for(int i=0; i<nums.size(); i++){
            sum+=nums[i];
            if(mp.find(sum-k)!=mp.end()){
                ans+=mp[sum-k];
            }
            mp[sum]++;
        }
        return ans;
    }
};
```

## 普通数组
### 轮转数组
+ 轮转数组：[189.轮转数组](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：先翻转整个数组，再翻转前 `k` 个元素和后 `k` 个元素就能得到答案。
+ 代码：

```cpp
class Solution {
public:
    void reverse(vector<int>& nums, int left, int right){
        while(left < right){
            swap(nums[left], nums[right]);
            right--;
            left++;
        }
    }
    void rotate(vector<int>& nums, int k) {
        if(nums.size() == 1)
            return;
        int mv = k % nums.size();
        // 先翻转整个数组
        reverse(nums, 0, nums.size()-1);
        // 再翻转前k个和后k个
        reverse(nums, 0, mv-1);
        reverse(nums, mv, nums.size()-1);
    }
};
```

## 矩阵
### 矩阵置零
+ 矩阵置零：[73.矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：首先找到找到 `0` 元素所在位置，再分别按照 `0` 元素所在位置的行和列都置为 `0` 。
+ 代码：

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        vector<int> row; // 行
        vector<int> col; // 列
        int m = matrix.size();
        int n = matrix[0].size();
        // 找到 0 元素所在位置
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(matrix[i][j] == 0){
                    row.push_back(i);
                    col.push_back(j);
                }
            }
        }
        // 按列置为0
        for(int i=0; i<row.size(); i++){
            for(int j=0; j<n; j++){
                matrix[row[i]][j] = 0;
            }
        }
        // 按行置为0
        for(int i=0; i<col.size(); i++){
            for(int j=0; j<m; j++){
                matrix[j][col[i]] = 0;
            }
        }
    }
};
```

## 链表
### 回文链表
+ 回文链表：[234.回文链表](https://leetcode.cn/problems/palindrome-linked-list/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：该题的思路分为三部分：
	+ 通过快慢指针找到链表中间，初始的时候（ `ListNode* slow = head;`、`ListNode* fast = head->next;` ）
	+ 翻转后半部分链表 (从 `slow->next` 开始， `ListNode* node = reverse(slow->next);` )
	+ 判断链表的前后两部分是否相等。
+ 代码：

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 反转链表函数
    ListNode* reverse(ListNode* head){
        ListNode* pre = nullptr;
        ListNode* node = nullptr;
        ListNode* cur = head;
        while(cur!=nullptr){
            node = cur->next;
            cur->next = pre;
            pre = cur;
            cur = node;
        }
        return pre;
    }
    
    bool isPalindrome(ListNode* head) {
        if(head == nullptr)
            return false;
        ListNode* slow = head;
        ListNode* fast = head->next;
        // 找到链表中间
        while(fast!=nullptr && fast->next!=nullptr){
            slow = slow->next;
            fast = fast->next->next;
        }
        // 翻转后半部分链表
        ListNode* node = reverse(slow->next);
        // 判断前后两部分是否相等
        ListNode* cur = head;
        while(cur!=nullptr && node!=nullptr){
            if(cur->val != node->val)
                return false;
            cur = cur->next;
            node = node->next;
        }
        return true;
    }
};
```

## 二叉树
### 二叉树的直径
+ 二叉树的直径：[543.二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：计算每个节点左子树的高度和右子树的高度相加即为经过该节点的最长直径，主要二叉树的最长直径不一定经过根节点，因此在递归计算每个节点的最长直径后取最大值保存，最终即为答案。
+ 代码：

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int travelsal(TreeNode* root, int& ans){
        // 终止条件
        if(root == nullptr)
            return 0;
        int leftH = travelsal(root->left, ans);
        int rightH = travelsal(root->right, ans);
        ans = max(ans, leftH+rightH);
        return max(leftH, rightH)+1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int ans = 0;
        int num = travelsal(root,ans);
        return ans;
    }
};
```

## 回溯
### 括号生成
+ 括号生成：[22.括号生成](https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：定义 `left` 和 `right` 分别表示左右括号的数量，终止条件为当左右括号的数量都为 `n` 的时候。递归过程中有两种情况：
	+ 一是左括号数量小于 `n` ( `left < n` )，此时能够往 `path` 里面加入左括号；
	+ 二是 `right<n && left>right` 这个条件下可以往 `path` 里面加右括号。
+ 代码：

```cpp
class Solution {
public:
    string path = "";
    vector<string> result;
    void backtracking(int n, int left, int right){
        // 终止条件
        if(left == n && right == n){
            result.push_back(path);
            return;
        }
        if(left < n){
            path.push_back('(');
            backtracking(n, left+1, right);
            path.pop_back();
        }
        if(right<n && left>right){
            path.push_back(')');
            backtracking(n, left, right+1);
            path.pop_back();
        }
        return;
    }

    vector<string> generateParenthesis(int n) {
        backtracking(n, 0, 0);
        return result;
    }
};
```

## 二分查找
### 搜索插入位置
+ 搜索插入位置：[35.搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：经典二分查找问题，可以通过模拟查找的过程找出问题所在。
+ 代码：

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size()-1;
        int mid = left+(right-left)/2;
        while(left<=right){
            mid = left+(right-left)/2;
            if(nums[mid] == target)
                return mid;
            if(nums[mid]>target){
                right = mid-1;
            }
            else{
                left = mid+1;
            }
        }
        return left;
    }
};
```

## 栈
### 最小栈
+ 最小栈：[155.最小栈](https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题首先定义两个栈，一个栈正常存储元素，另一个栈为最小值栈，当入栈的元素小于最小栈元素就将该最小值加入到最小栈中，否则去最小栈的栈顶元素重新加入到最小栈。

![最小栈](https://yugin-blog-1313489805.cos.ap-guangzhou.myqcloud.com/202509121433596.png)

+ 代码：

```cpp
class MinStack {
public:
    stack<int> st;
    stack<int> min_st;

    MinStack() {   
        min_st.push(INT_MAX);
    }
    
    void push(int val) {
        if(val < min_st.top())
            min_st.push(val);
        else
            min_st.push(min_st.top());
        st.push(val);
    }
    
    void pop() {
        min_st.pop();
        st.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return min_st.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 字符串编码
+ 字符串编码：[394.字符串编码](https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：定义一个 `string` 类型的辅助栈，
	+ 1、遍历字符串并压栈直到遇到 `"]"` ;
	+ 2、定义辅助 `string` 类型的 `tmp` 并弹出栈直到遇到 `"["`，将字符串记录至 `tmp`，注意从左边加到右边，最后弹出 `"["` ; 
	+ 3、定义辅助 `string` 类型的 `num` 并弹出栈直到字符不再是数字，将重复的次数加到 `num` 中，注意从左边加到右边；
	+ 4、通过 `stoi(num)` 将 `string` 类型转换为 `int` 类型，并采用 `for` 循环构建重复的字符串，并重新压入栈中；
	+ 5、最后从左边到右边拼接栈中字符串即可得到结果。
+ 代码：

```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<string> st;
        for(int i=0; i<s.size(); i++){
            if(s[i]!=']'){
                string tmp = "";
                tmp += s[i];
                st.push(tmp);
            }
            if(s[i] == ']'){
                string tmp = "";
                while(st.top()!="["){
                    tmp=st.top()+tmp; // 注意从左边加到右边
                    st.pop();
                }
                st.pop(); // 弹出"["
                // num
                string num = "";
                while(!st.empty() && st.top()[0]<='9' && st.top()[0]>='0'){
                    num=st.top()+num; // 注意从左边加到右边
                    st.pop();
                }
                // 拼接字符串
                string cnt = "";
                int n = stoi(num);
                for(int i=0; i<n; i++){
                    cnt=tmp+cnt;
                }
                st.push(cnt);
            }
        }
        string result;
        while(!st.empty()){
            result=st.top()+result; // 注意从左边加到右边
            st.pop();
        }
        return result;
    }
};
```

## 堆
### 数据流的中位数
+ 数据流的中位数：[295.数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：直接排序复杂度高，所以引入 **两个堆**：
	+ **大根堆（`left_que`）**：存储较小的一半数，堆顶是这部分的最大值。
	+ **小根堆（`right_que`）**：存储较大的一半数，堆顶是这部分的最小值。
	+ 为了能直接取出中位数，必须维持两个不变量：
		+ **有序性不变量**：所有左边的元素 ≤ 所有右边的元素，即：`left_que.top() <= right_que.top()`，这样两个堆的交界就是中间。
		+ **规模平衡不变量**：两个堆的元素个数差不超过 `1`（注意这里不要用 `left_que.size() - right_que.size() > 1` 来判断，因为 `size_t` 是无符号数，负数会被解释成一个非常大的正整数），保证总数为奇数时，中位数就是元素更多的那边的堆顶，总数为偶数时，中位数就是两个堆顶的平均。
+ 代码：

```cpp
class MedianFinder {
public:
    // 大根堆（less小于号，从小到大）
    priority_queue<int, vector<int>, less<int>> left_que;
    // 小根堆（greater大于号，从大到小）
    priority_queue<int, vector<int>, greater<int>> right_que;

    MedianFinder() {
        
    }
    
    void addNum(int num) {
        right_que.push(num);
        if(!left_que.empty() && !right_que.empty() && left_que.top()>right_que.top()){
            left_que.push(right_que.top());
            right_que.pop();
        }
        if(right_que.size() > left_que.size()+1){
            left_que.push(right_que.top());
            right_que.pop();
        }
        if(left_que.size() > right_que.size()+1){
            right_que.push(left_que.top());
            left_que.pop();
        }
    }
    
    double findMedian() {
        if(left_que.size()>right_que.size())
            return left_que.top();
        if(right_que.size()>left_que.size())
            return right_que.top();
        return (left_que.top()+right_que.top())/2.0;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

## 动态规划
### 杨辉三角
+ 杨辉三角：[118.杨辉三角](https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：先特殊处理前两行，然后从第三行开始，每一行的首尾固定为 `1`，中间元素由上一行相邻两个数相加，逐行生成直至 `numRows`。
+ 代码：

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result;
        vector<int> path1(1,1);
        result.push_back(path1);
        if(numRows == 1)
            return result;
        vector<int> path2(2,1);
        result.push_back(path2);
        if(numRows == 2)
            return result;
        for(int i=2; i<numRows; i++){
            vector<int> path(i+1,1);
            for(int j=1; j<=path.size()-2; j++){
                path[j] = result[i-1][j-1]+result[i-1][j];
            }
            result.push_back(path);
        }
        return result;
    }
};
```