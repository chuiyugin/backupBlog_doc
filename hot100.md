---
title: 热题100学习笔记
tags:
  - 算法学习
categories:
  - 算法学习
date: 2025-9-7 15:00:00
excerpt: C++、编程语言、算法学习
---
# 热题100学习笔记
## 哈希
### 字母异位词分组
+ 字母异位词分组：[49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题目通过长度为 `26` 的 `string` 记录字母数量一样的字符串（由于 `unordered_map` 要求 `Key` 是可哈希的，因此 `Key` 不能够存 `vector` 类型），通过 `unordered_map` 来找到属于相同字母异位词的字符串，最后将其合并到数组中。

![字母异位词分组的存储结构](https://yugin-blog-1313489805.cos.ap-guangzhou.myqcloud.com/202509071517393.png)

+ 代码：

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> result;
        unordered_map<string, vector<string>> mp;
        for(int i=0; i<strs.size(); i++){
            string index(26, 0);
            for(int j=0; j<strs[i].size(); j++){
                index[strs[i][j] - 'a']++;
            }
            mp[index].push_back(strs[i]);
        }
        for(unordered_map<string, vector<string>>::iterator it = mp.begin(); it!=mp.end(); it++){
            result.push_back((*it).second);
        }
        return result;
    }
};
```

## 双指针
### 移动零
+ 移动零：[283.移动零](https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题目采用双指针的解法，首先定义 `left` 和 `right` 同时指向 `0` 位置，移动 `right` 指针，当 `right` 所指的元素不等于 `0` 时，交换 `left` 和 `right` 所指的元素，并且 `left` 右移一位。
	+ 需要注意的是不需要保证 `left` 初始指向的是 `0`，`left` 如果初始指向的是非 `0`，那么 `left` 和 `right` 就会指向同一个位置，同一个位置互换等于没有操作，之后 `left` 和 `right` 指针一起往右边移动一位。只有当 `left` 第一次值为 `0` 的时候，`right` 就会和 `left` 指针分离，直到找到一个非 `0` 的数然后跟 `left` 去进行交换。
+ 代码：

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0;
        for(int right = 0; right<nums.size(); right++){
            if(nums[right] != 0){
                swap(nums[left], nums[right]);
                left++;
            }
        }
    }
};
```

## 滑动窗口
### 无重复字符的最长子串
+ 无重复字符的最长子串：[3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：用两个指针 `left` 和 `right` 表示当前考察的窗口区间 `[left, right)`。`unordered_set<char>` 用来存储窗口内的字符，保证窗口内不出现重复。（滑动窗口+哈希集合）的问题。
	+ 当 `s[right]` 不在集合里时，说明窗口可以安全**扩张**，将 `s[right]` 插入集合，`right++` 向右移动，更新最大长度 `result = max(result, right - left)` 。
	+ 当 `s[right]` 已经在集合中时，说明出现重复字符，删除 `s[left]`， `left++` **收缩**窗口，直到窗口内没有重复字符。
+ 代码：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> se;
        int left = 0;
        int right = 0;
        int result = 0;
        while(right<s.size() && left<=right){
            if(se.find(s[right]) == se.end()){
                se.insert(s[right]);
                right++;
            }
            else{
                se.erase(s[left]);
                left++;
            }
            result = max(result, right-left);
        }
        return result;
    }
};
```

## 子串
### 和为 K 的子数组
+ 和为 K 的子数组：[560.和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：这道题是典型的前缀和+哈希表解法，用来统计和为 `k` 的连续子数组个数。
	+ 在开始时放入 `mp[0] = 1`，表示「前缀和为 0 出现过 1 次」，这样可以处理从数组开头开始的子数组。
	+ 用一个哈希表 `mp` 存储某个前缀和出现的次数。在遍历过程中，此时前缀和为 `sum` 时，只要 `sum - k` 在哈希表中存在，说明之前有某个前缀和能让子数组和刚好为 `k`。于是把 `mp[sum - k]` 累加到答案 `ans` 中。
+ 代码：

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int sum = 0;
        int ans = 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        for(int i=0; i<nums.size(); i++){
            sum+=nums[i];
            if(mp.find(sum-k)!=mp.end()){
                ans+=mp[sum-k];
            }
            mp[sum]++;
        }
        return ans;
    }
};
```

## 普通数组
### 轮转数组
+ 轮转数组：[189.轮转数组](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：先翻转整个数组，再翻转前 `k` 个元素和后 `k` 个元素就能得到答案。
+ 代码：

```cpp
class Solution {
public:
    void reverse(vector<int>& nums, int left, int right){
        while(left < right){
            swap(nums[left], nums[right]);
            right--;
            left++;
        }
    }
    void rotate(vector<int>& nums, int k) {
        if(nums.size() == 1)
            return;
        int mv = k % nums.size();
        // 先翻转整个数组
        reverse(nums, 0, nums.size()-1);
        // 再翻转前k个和后k个
        reverse(nums, 0, mv-1);
        reverse(nums, mv, nums.size()-1);
    }
};
```

## 矩阵
### 矩阵置零
+ 矩阵置零：[73.矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-100-liked)
+ 思路：首先找到找到 `0` 元素所在位置，再分别按照 `0` 元素所在位置的行和列都置为 `0` 。
+ 代码：

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        vector<int> row; // 行
        vector<int> col; // 列
        int m = matrix.size();
        int n = matrix[0].size();
        // 找到 0 元素所在位置
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(matrix[i][j] == 0){
                    row.push_back(i);
                    col.push_back(j);
                }
            }
        }
        // 按列置为0
        for(int i=0; i<row.size(); i++){
            for(int j=0; j<n; j++){
                matrix[row[i]][j] = 0;
            }
        }
        // 按行置为0
        for(int i=0; i<col.size(); i++){
            for(int j=0; j<m; j++){
                matrix[j][col[i]] = 0;
            }
        }
    }
};
```