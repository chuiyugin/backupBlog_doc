---
title: 知识复习汇总
tags:
  - 面经
categories:
  - 面经
date: 2025-2-20 23:30:00
excerpt: 面经汇总
---

# 知识复习汇总
## 数据结构
### 哈希相关
+ 简单介绍一下哈希表？
	+ 哈希表是一种根据键（Key）直接计算出**存储位置**的数据结构。能够通过哈希函数 (Hash Function) 把键映射到一个数组的索引上，从而实现快速的增删查改操作。
+ 什么是解决哈希冲突？
	+ 哈希表用哈希函数把键映射到桶（数组槽位）。不同键可能落到同一桶，这就是**冲突**。冲突不可避免，核心是：**怎么在冲突出现时，仍保持增删查改接近 O (1) 的开销**。
+ 如何解决哈希冲突？
	+ 1、拉链法：每个桶保存一个“容器”（通常是链表、动态小数组或小型平衡树）。冲突的元素都挂到该桶的容器里。
	+ 2、线性探测法：在哈希表中，如果某个键经过哈希函数映射得到的槽位（bucket）已被占用，就按照一个固定的探测序列去找下一个空槽。
	+ 3、二次探测法：发生冲突时，它不像线性探测法一样一步步顺序探测，而是按照**二次方步长**往外扩展。
	+ 4、双重散列：当发生冲突时，不是固定加 1（线性探测），也不是平方步长（二次探测），而是用“第二个哈希函数”决定探测步长。
+ 如果用散列链表解决哈希冲突，那么查找时间复杂度会变成 $O(n)$ ，如何下降时间复杂度？
	+ 1、控制负载因子：让期望复杂度回到 $O(1)$，负载因子 α = 元素数/桶数，当 α 逼近设定阈值的时候就扩容➕重新哈希
	+ 2、优化哈希函数：降低冲突几率
	+ 3、桶内结构升级：把链表换成平衡树

### 排序相关
+ 稳定排序和不稳定排序
	+ 如果一个排序算法在对一组数据进行排序时，**相等的元素在排序后仍然保持它们原来的相对顺序**，那么这种算法就是**稳定的**。
	+ 若相等的元素在排序后**相对顺序可能发生变化**，这种算法就是**不稳定的**。
+ 稳定排序算法

![稳定排序算法](https://yugin-blog-1313489805.cos.ap-guangzhou.myqcloud.com/202510060105044.png)

+ 不稳定排序算法：

![不稳定排序算法](https://yugin-blog-1313489805.cos.ap-guangzhou.myqcloud.com/202510060107616.png)

+ 快排为什么不稳定？
	+ 快速排序的主要过程是：
		1. **选择一个基准（pivot）**；
		2. **将数组分为三部分**：
		    - 左边放比基准小的元素；
		    - 中间放和基准相等的元素；
		    - 右边放比基准大的元素；
		3. **递归地对两部分进行排序**。
	+ 快速排序的**不稳定性**来源于——**“交换操作”可能跨越相等元素之间的原始相对顺序**。

## 语言语法
### Golang
#### GMP 相关
+ 当一个 `goroutine` 进入系统调用被阻塞，底层线程与 `p` 如何解绑？
	+ 在系统调用前，首先该线程 `m` 的 `g0` 会保存当前 `g` 的执行环境
	+ 然后将 `g` 和 `p` 的状态更新为 `syscall`；
	+ 解除 `p` 和当前 `m` 之间的绑定，因为 `m` 即将进入系统调用而导致短暂不可用；
	+ 最后将 `p` 添加到当前 `m` 的 `oldP` 容器当中，后续 `m` 恢复后，会优先寻找旧的 `p` 重新建立绑定关系。
+ 当 `m` 完成了内核态的系统调用之后，如何寻找 `p` 开始重新运作？
	+ 方法执行之初，此时的执行权是普通 `g` 倘若此前设置的 `oldp` 仍然可用，则重新和 `oldP` 绑定，将当前 `g` 重新置为 `_Grunning` 状态，然后开始执行后续的用户函数；
	+ `old` 绑定失败，则调用 `mcall` 方法切换到 `m` 的 `g0`，并执行 `exitsyscall0` 方法；
	+ 将 `g` 由系统调用状态切换为可运行态（`_Grunnable`），并解绑 `g` 和 `m` 的关系；
	+ 从全局 `p` 队列获取可用的 `p`，如果获取到了，则执行 `g`；
	+ 如若无 `p` 可用，则将 `g` 添加到全局队列，当前 `m` 陷入沉睡，直到被唤醒后才会继续发起调度。
+ 讲讲 Go 协程：
	+ 与线程存在映射关系，为 `M:N`，`M` 可以大于 `N`；
	+ 创建、销毁、调度在用户态完成，对内核透明，足够轻便；
	+ 可利用多个线程，实现并行；
	+ 通过调度器 `p` 的斡旋，实现和线程间的动态绑定和灵活调度；
	+ 栈空间大小可动态扩缩，因地制宜。
+ 讲讲 GMP 模型中 `p` 的作用，一定需要 `p` 吗？
	+ `p` 即 `processor`，是 `golang` 中协程的调度器；
	+ `p` 是 `gmp` 的中枢，借由 `p` 承上启下，实现 `g` 和 `m` 之间的动态有机结合；
	+ 对 `g` 而言，`p` 是其 `cpu`，`g` 只有被 `p` 调度，才得以执行；
	+ 对 `m` 而言，`p` 是其执行代理，为其提供必要信息的同时（可执行的 `g`、内存分配情况等），并隐藏了繁杂的调度细节；
	+ `p` 的数量决定了 `g` 最大并行数量，可由用户通过 `GOMAXPROCS` 进行设定（超过 `CPU` 核数时无意义）。
	+ 在目前的 GMP 模型下，`p` 是必须的，当去掉 `p` 让 `m` 从全局队列中直接取 `g` 进行执行的话会导致无法高效控制并行度，导致运行效率大幅下降。

## 计网相关
### HTTP 篇
+ HTTPS 比 HTTP 安全在哪？证书在其中起到什么作用，如何验证证书？
	+ HTTP 是明文传输的，传输的数据未经过加密，而 HTTPS 在 HTTP 基础上引入了 **SSL/TLS 协议**，提供了三大安全能力（加密、数据完整性、身份验证）；
	+ 证书由权威的 CA（证书颁发机构）签发，里面包含以下关键内容（服务器的公钥、服务器的域名信息、证书有效期、CA 的数字签名）
	+ 客户端拿到服务器的证书，沿着签发链（服务器证书 → 中级 CA → 根 CA）逐层验证签名是否有效。
	+ 检查证书中记录的域名是否与访问的网站一致。
	+ 确认证书是否在有效期内。
	+ 通过 CRL（证书吊销列表）或 OCSP 协议验证证书是否已被吊销。
	+ 如果以上都通过，浏览器才会信任这个证书，并继续进行 **TLS 握手**，协商出对称密钥来加密后续通信。
+ 对称密钥和非对称的区别？
	+ 对称密钥：
		+ 加密和解密使用**同一把密钥**。通信双方需要共享一把密钥。
		+ 假如有 N 个用户相互通信，就需要 $\frac{N(N-1)}{2}$ ​ 把不同的密钥，管理起来比较复杂。
		+ 加密解密速度快，适合处理大量数据。
		+ 缺点：如何安全地分发和保存密钥是个难题，如果密钥泄露，通信内容也就不安全了。
	+ 非对称加密：
		+ 加密和解密使用**一对密钥**：公钥 (Public Key) 和私钥 (Private Key)。公钥可以公开，用来加密数据。私钥必须保密，用来解密数据。
		+ 每个人只需要维护自己的一对密钥（公钥和私钥）。公钥可以对外公开，私钥由自己保管，密钥管理相对简单。
		+ 加密解密速度慢，性能消耗大，但安全性更高，因为私钥不需要传输。
		+ 通常用来做：
		    - **数字签名**（保证身份和不可否认性）
		    - **密钥交换**（先用非对称加密交换对称密钥，再用对称密钥加密数据）
- TLS 的四次握手流程
	- 1、客户端发起请求：告诉服务器自己支持的 TLS 版本、加密算法套件、随机数 (用于生产后续的会话密钥，也就是对称密钥)。
	- 2、服务器回应：选择使用的 TLS 版本和加密算法、发送自己的随机数（也是用于生产后续的会话密钥，也就是对称密钥）、发送服务器证书（包含服务器公钥，用于身份认证）。
	- 3、客户端再次发起请求做会话密钥协商：客户端生成一个“预主密钥” (Pre-Master Secret)，用服务器的公钥加密后发给服务器。同时发送加密算法改变通知，表示后续信息都用会话密钥来加密。
	- 4、服务端通过“预主密钥” (Pre-Master Secret)计算出会话密钥后向客户端发信息：发送加密算法改变的通知，表示后续信息都用会话密钥来加密。

### DNS 相关
+ 在浏览器输入栏中输入 `baidu.com` 发生了什么？
	+ 为了找到 `baidu.com` 对应的服务器 IP 地址，浏览器会按层次查找缓存：
		1. **浏览器 DNS 缓存**  
		    + 若近期访问过，会直接命中缓存。
		2. **操作系统缓存（OS Cache）**  
		    + 否则，向操作系统查询本地缓存（例如 Windows 的 `DNS Client Service`）。
		3. **本地 hosts 文件**  
		    + 检查系统文件 `/etc/hosts`（Linux/Mac）或 `C:\Windows\System32\drivers\etc\hosts` 是否有静态映射。
		4. **本地 DNS 服务器（ISP 或路由器）**  
		    + 若都没有命中，系统会向配置的 DNS 服务器（例如电信、Google DNS 8.8.8.8）发起 DNS 查询请求。
+ DNS 什么时候用递归查询，什么时候用迭代（反复）查询？
	+ 递归查询（客户端 → 本地 DNS 服务器），意思是：“帮我查出 `baidu.com` 的 IP 地址，不要让我再管后面的细节。”
	+ 迭代查询（本地 DNS → 其他上级 DNS 服务器），这些过程中，每一层上级 DNS 都**不会代为继续查询**，只告诉下一级地址。
+ DNS 根服务器会不会同时接收到大量并发查询请求？
	+ 是的：根服务器会接收到大量并发查询
	+ 为什么根服务器能扛住如此高并发？
		+ 分布式部署（Anycast 技术），全球共有 **超过 1000+ 台根服务器实例**（通过 Anycast 技术部署在各地）。
		+ 高缓存利用率，实际上，绝大多数 DNS 查询 **根本不会真的到达根服务器**，**本地 DNS 服务器**（ISP 或公司内部 DNS）会缓存查询结果； `.com`、`.net` 等 **顶级域名服务器** 也会被缓存；根域的权威信息（比如顶级域的 NS 记录）**变化极少**，TTL 时间长（通常为 48 小时甚至更长）。
		+ 根区数据非常小且易处理；
+ 百度是如何处理大量对 `baidu.com` 的并发请求的？
	+ 1. DNS 多层调度 + 全球加速：当你访问 `baidu.com`，其实并不止一个 IP。同一个域名对应多个服务器 IP；根据用户地理位置，返回**距离最近**的服务器地址；DNS 还会考虑各节点的负载情况、延迟、可用性。
	+ 2. CDN（内容分发网络）缓存静态资源：静态资源（图片、CSS、JS、搜索页面模板等）被分发到全国各地的边缘节点。页面中的图片、脚本等资源**就近从 CDN 节点获取**；只有动态内容（如搜索结果）才需回源请求百度主站。
	+ 3. 分布式缓存与异步队列、高可扩展的搜索索引集群、健壮的监控与容灾体系等方式应对大量并发请求。